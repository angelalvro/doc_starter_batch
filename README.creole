= Documentaci√≥n Starter Batch =

== Introducci√≥n ==

Este documento describe el flujo, configuraci√≥n y componentes involucrados en el proceso de ejecuci√≥n de un //cronjob// utilizando el starter batch.  
Se detallan los requisitos previos, las configuraciones necesarias y los enlaces relevantes a las Implementaciones de Referencia (RI) de cada componente.  
El prop√≥sito del **starter batch** es proporcionar todas las funcionalidades y la autoconfiguraci√≥n necesarias para facilitar la ejecuci√≥n de //cronjobs// definidos en la nube **OpenShift**.

Los //cronjobs// son desplegados en OpenShift con una programaci√≥n deliberadamente inv√°lida, lo que evita su ejecuci√≥n autom√°tica.  
De esta forma, existen en el cl√∫ster pero quedan a la espera de ser disparados por el framework NAUA.  
El encargado de orquestar su activaci√≥n, as√≠ como la gesti√≥n de **jobs**, es el propio framework NAUA, haciendo uso de este starter.

La ejecuci√≥n de cada //job// est√° protegida mediante un mecanismo de seguridad basado en **tokens** y **scopes**,  
lo que garantiza que solo componentes autorizados puedan iniciar procesos en el entorno de ejecuci√≥n.

== Requisitos Previos ==

* **üìÑ Cronjob en OpenShift** 
  Es necesario disponer del //cronjob// que se desea ejecutar, desplegado en el entorno de ejecuci√≥n.  
  Este componente debe incorporar el starter batch.  


* **üì° Topics Kafka** 
  Es necesario solicitar los topics para comunicaci√≥n entre los componentes.  
  La validaci√≥n y el lanzamiento del cronjob se activan mediante el consumo de eventos.  


* **üîê Client ID** 
  Cada batch debe estar asociado a un //client ID// para su trazabilidad y autenticaci√≥n.  

== Funcionalidades del Starter Batch ==

=== Funcionalidades Cronjob dentro del Starter Batch ===

El siguiente esquema ilustra la arquitectura funcional relacionada con la ejecuci√≥n de Cronjobs del **Starter Batch**.  
En √©l se representan los principales componentes involucrados as√≠ como su interacci√≥n con el sistema de eventos **Kafka**.

{{Diagrama Funcionalidad Cronjob.drawio.png|}}
==== üõ†Ô∏è JobLaunchHelper: ejecuci√≥n controlada del proceso ====

El componente {{{JobLaunchHelper}}} encapsula la l√≥gica necesaria para lanzar un //job// dentro de la arquitectura de referencia.  
Su funci√≥n principal es garantizar que la ejecuci√≥n del proceso batch est√© autorizada y parametrizada de forma segura.

* **Autorizaci√≥n basada en scopes** 
  Cada job define una lista de //scopes// necesarios para su ejecuci√≥n.  
  Estos scopes representan permisos que deben estar presentes en el entorno de ejecuci√≥n, inyectados din√°micamente mediante un {{{ConfigMap}}}  
  por un servicio externo que valida la petici√≥n. Por ejemplo:

  {{{  
  jobLaunchHelper.launchJob(  
      userJob,  
      List.of("ed-naua-manager"),  
      JobScopesOperator.AND  
  );  
  }}}

  El helper verifica que el conjunto de scopes disponibles incluye (seg√∫n el operador {{{AND}}} o {{{OR}}}) los que requiere el job.  
  Si no se cumple esta condici√≥n, la ejecuci√≥n se rechaza.  

* **Construcci√≥n din√°mica de par√°metros**
  El helper lee los //JobParameters// definidos {{{(ver validador/lanzador gesti√≥n de JobParameters)}}},  
  los transforma y los incluye como //JobParameters// al invocar el job.  
  Puedes encontrar m√°s informaci√≥n en la documentaci√≥n oficial de Spring Batch sobre el uso de los //JobParameters//:
  https://docs.spring.io/spring-batch/reference/domain.html#jobParameters  

* **Ejecuci√≥n controlada**
  Si la validaci√≥n es exitosa, el job se lanza mediante {{{JobLauncher}}}.  
  En caso contrario, se env√≠a un evento de rechazo y el contenedor termina con c√≥digo de error.  

Gracias a este mecanismo, se asegura que solo los procesos autorizados ‚Äîes decir, aquellos con los scopes adecuados inyectados‚Äî  
puedan activar un job en un entorno de ejecuci√≥n concreto.

==== Notificaciones del resultado de la ejecuci√≥n del job mediante eventos ====

El **starter batch** incluye un sistema de notificaciones basado en eventos Kafka que permite informar del resultado de la ejecuci√≥n de cada job.  
Estas notificaciones se publican en un topic espec√≠fico, y pueden ser de dos tipos:

* **‚úÖ Evento OK:** indica que el job se ha ejecutado correctamente.
* **‚ùå Evento KO:** se emite si el job no pudo ejecutarse por no cumplir requisitos previos, como la ausencia de scopes necesarios.

Ambos tipos de eventos utilizan como carga √∫til un objeto {{{JobResultEvent}}}  
y son publicados en un topic nombrado con el siguiente patr√≥n:

{{{  
tp.<cappCode>.<cronjob>-fin-batch  
}}}

El nombre del //cronjob// y el c√≥digo de la aplicaci√≥n ({{{cappCode}}}) se extraen de la configuraci√≥n del entorno,  
lo que permite construir din√°micamente el nombre del topic en tiempo de ejecuci√≥n.

* **üì§ Evento OK** 
  Generado por {{{JobCompletionNotificationService}}} cuando el job se ejecuta con √©xito.  
  Incluye el resultado y la cabecera {{{JOB_CORRELATION}}} si est√° presente.  

* **üö´ Evento KO**
  Emitido por {{{JobRejectedNotificationService}}} cuando el job no cumple las condiciones necesarias (por ejemplo, scopes insuficientes).  
  Se publica un evento {{{JobResultEvent}}} con el c√≥digo {{{MISSING_SCOPES}}}.  

Esta estrategia permite que otros componentes del sistema est√©n informados del estado de los procesos batch y puedan reaccionar en consecuencia.

Para habilitar toda esta infraestructura de gesti√≥n de eventos de forma autom√°tica,  
es necesario anotar la clase principal del servicio con {{{@EnableBatchCronjob}}}.

Esta anotaci√≥n activa la configuraci√≥n autom√°tica proporcionada por el starter batch, que incluye:

* Creaci√≥n de consumidores de eventos para activar el //cronjob//.  
* Configuraci√≥n de productores Kafka para publicar eventos de estado.  
* Registro autom√°tico de listeners y servicios de notificaci√≥n.

Gracias a esta anotaci√≥n, el servicio queda conectado al ecosistema de eventos sin necesidad de configuraci√≥n expl√≠cita adicional.

===== üì£ Job Listener =====

El {{{GissJobCompletionListener}}} es un componente clave en el ciclo de vida de un //job// dentro del starter batch.  
Implementa la interfaz {{{JobExecutionListener}}} de Spring Batch y se encarga de interceptar el evento de finalizaci√≥n  
del proceso batch para recopilar informaci√≥n detallada sobre su ejecuci√≥n.

Una vez finalizado el //job//, el listener construye un objeto {{{JobCompletionDTO}}} con la siguiente informaci√≥n:

* **Identificador del job** y **nombre** del job ejecutado.  
* **Par√°metros** con los que se lanz√≥ el proceso.  
* **Estado de salida** global del job, incluyendo c√≥digo y descripci√≥n.  
* **Metadatos temporales**: fechas de creaci√≥n, inicio, fin y √∫ltima actualizaci√≥n del proceso.
* **Detalle por pasos (steps)** : para cada uno de los steps ejecutados, se almacena su nombre, estado de salida,  
  tiempos de ejecuci√≥n y √∫ltima actualizaci√≥n.

Con toda esta informaci√≥n, el listener construye un {{{JobResultEvent}}}, que encapsula tanto los metadatos de ejecuci√≥n  
como un **c√≥digo de resultado l√≥gico** ({{{JobResultCode}}}). Este c√≥digo se deriva del //exitCode// del proceso,  
siguiendo la siguiente l√≥gica:

{{{
"COMPLETED" ‚Üí SUCCESS  
"FAILED"    ‚Üí FAILED  
"STOPPED"   ‚Üí STOPPED  
"NOOP"      ‚Üí NOOP  
Cualquier otro valor ‚Üí UNKNOWN  
}}}

Una vez generado el {{{JobResultEvent}}}, el listener lo env√≠a al topic Kafka {{{tp.<cappCode>.<cronjob>-fin-batch}}}  
a trav√©s del {{{JobCompletionNotificationService}}}.

Este listener es registrado autom√°ticamente por el starter batch si la clase principal del servicio est√° anotada con  
{{{@EnableBatchCronjob}}}.

===== ü™µ Funcionalidades de Logging en Procesos Batch =====

El starter batch incorpora una serie de **listeners de logging** preconfigurados que permiten auditar y registrar  
la ejecuci√≥n de jobs, steps y chunks.  
Estos listeners est√°n disponibles como beans Spring de forma condicional, seg√∫n las propiedades definidas en el fichero de configuraci√≥n.

Entre los principales componentes de logging, se encuentran:

* **{{{GissLoggingJobErrorListener}}}** : registra errores y resultados al finalizar un {{{Job}}}. 
* **{{{GissLoggingStepErrorListener}}}** : registra el estado y excepciones producidas en cada {{{Step}}}.  
* **{{{GissLoggingChunkErrorListener}}}** : captura errores en la ejecuci√≥n de //chunks// durante la lectura/proceso/escritura. 
* **{{{GissLoggingWriterListener}}}** : permite loguear lo que ocurre espec√≠ficamente durante la escritura de datos. 

Estos componentes est√°n activados por defecto, por lo que no es necesario configurarlos manualmente.  
Sin embargo, si se desea desactivar alguno de ellos, se puede hacer mediante la configuraci√≥n correspondiente en {{{application.yml}}}.  
Por ejemplo, para desactivar el listener de logging a nivel de {{{Job}}}:

{{{  
giss:  
  batch:  
    logging-listeners:  
      job:  
        enabled: false  
}}}

Finalmente, todos estos listeners pueden ser registrados de forma autom√°tica en el job mediante el uso del  
{{{LoggingListenersPostProcessor}}}, que los asocia din√°micamente a los beans de tipo {{{Job}}} o {{{Step}}}.

===== üì° Funcionalidades de Tracing en Procesos Batch =====

Para facilitar la **observabilidad y trazabilidad** de los procesos batch, se incluye un componente de tracing  
basado en {{{BatchObservabilityBeanPostProcessor}}}, que forma parte de Spring Batch.

Este componente permite integrar autom√°ticamente el sistema de monitorizaci√≥n y trazado distribuido  
(como //OpenTelemetry// o //Micrometer//), proporcionando informaci√≥n detallada sobre la ejecuci√≥n de los jobs y steps.

Puedes encontrar m√°s informaci√≥n en la documentaci√≥n oficial de Spring Batch sobre tracing:  
https://docs.spring.io/spring-batch/reference/tracing.html

==== Funcionalidades del Starter Batch (Validador Lanzador) ====

==== Funcionalidades del Starter Batch (Solicitante) ====

==== Funcionalidades del Starter Batch (Comun) ====

---

=== Componentes de la Arquitectura Batch ===

=== 1. Servicio proceso Batch ===

Es el componente principal en la arquitectura batch, emcapsula el proceso batch en s√≠ mismo.  
Este servicio har√° uso del Chart Cronjob para su despliegue en el cluster OpenShift.  
El resultado de la ejecuci√≥n del Chart Cronjob ser√° un recurso Cronjob con una programaci√≥n deliberadamente inv√°lida  
y con la imagen del servicio que alberga la l√≥gica funcional del proceso batch.

==== Configuraci√≥n de dependencias ====

El servicio que ejecuta el proceso batch debe incorporar tanto el starter batch como el starter JPA del framework NAUA.  
El starter batch utiliza JPA para gestionar la persistencia del estado de ejecuci√≥n de los //jobs//.  
Esto permite mantener un registro hist√≥rico, reintentar ejecuciones fallidas desde el punto de fallo y evitar duplicidades  
si se lanza el mismo job con los mismos par√°metros.

Spring Batch guarda esta informaci√≥n en una base de datos mediante JPA, lo que facilita la trazabilidad y el control de las ejecuciones dentro del framework NAUA.  
(Enlace spring batch)

{{{
<dependency>
<groupId>es.giss.arch</groupId>
<artifactId>giss-arch-starter-jpa</artifactId>
</dependency>
<dependency>
<groupId>es.giss.arch</groupId>
<artifactId>giss-arch-starter-batch</artifactId>
</dependency>
<dependency>
<groupId>com.oracle.database.jdbc</groupId>
<artifactId>ojdbc8</artifactId>
<scope>runtime</scope>
</dependency>
}}}

==== üîÑ Proceso de ejecuci√≥n del batch ====

La ejecuci√≥n del proceso batch se inicia desde la clase principal del servicio, que implementa {{{CommandLineRunner}}}.  
En este punto es donde se invoca al {{{JobLaunchHelper}}} para lanzar el job correspondiente.  
Un ejemplo t√≠pico de esta configuraci√≥n es el siguiente:

{{{
@SpringBootApplication
@RequiredArgsConstructor
@EnableScheduling
@EnableBatchCronjob
public class Application implements CommandLineRunner {

    private final Job userJob;
    private final JobLaunchHelper jobLaunchHelper;

    public static void main(final String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(final String... args) {
        jobLaunchHelper.launchJob(
            userJob,
            List.of("ed-naua-manager"),
            JobScopesOperator.AND
        );
    }
}
}}}

En este ejemplo, el job {{{userJob}}} es la definici√≥n del proceso batch, y se lanza √∫nicamente si se cumplen los //scopes// requeridos.  
El helper se encarga de validar los permisos, construir los par√°metros y lanzar el job si todo es correcto.

==== üß© Integraci√≥n del Listener en los procesos batch ====

Para que el {{{GissJobCompletionListener}}} act√∫e sobre los procesos batch, es necesario registrarlo expl√≠citamente en la definici√≥n del //Job//.  
Esta integraci√≥n se realiza dentro de una clase de configuraci√≥n Spring marcada con {{{@Configuration}}}, donde se define el bean del //Job//  
que encapsula la l√≥gica del proceso batch.

A continuaci√≥n, se muestra un ejemplo real de c√≥mo inyectar el listener en un proceso batch que define dos pasos ({{{step1}}} y {{{step2}}}):

{{{
@Configuration
@RequiredArgsConstructor
public class JobConfiguration {

    private final JobRepository jobRepository;
    private final GissJobCompletionListener jobCompletionListener;
    private final GissLoggingJobErrorListener gissLoggingJobErrorListener;
    private final JobLaunchHelper jobLaunchHelper;

    @Qualifier("step1")
    private final Step step1;

    @Qualifier("step2")
    private final Step step2;

    @Bean
    public Job userJob() {
        return new JobBuilder(jobLaunchHelper.getJobNameFromConfigMap(), jobRepository)
                .incrementer(new RunIdIncrementer())
                .listener(jobCompletionListener)                 // Listener que env√≠a el evento JobResultEvent
                .listener(gissLoggingJobErrorListener)           // Listener para loguear errores durante la ejecuci√≥n
                .start(step1)
                .next(step2)
                .build();
    }
}
}}}

En este ejemplo:

* **{{{jobCompletionListener}}}**: es el {{{GissJobCompletionListener}}} que se encargar√° de emitir el evento {{{JobResultEvent}}} al finalizar la ejecuci√≥n del job.  
* **{{{gissLoggingJobErrorListener}}}**: es un listener adicional que permite loguear los errores ocurridos durante la ejecuci√≥n.  
* **{{{RunIdIncrementer}}}**: garantiza que se permita la ejecuci√≥n del mismo job m√°s de una vez, usando un identificador √∫nico por ejecuci√≥n.  

Ambos listeners deben estar definidos como beans en el {{{ApplicationContext}}} para que puedan ser inyectados autom√°ticamente por Spring.  
Si est√°s utilizando el {{{@EnableBatchCronjob}}}, estos componentes son provistos autom√°ticamente por el starter batch.

=== 2. Servicio Validador/Lanzador ===

