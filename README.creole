== Documentaci√≥n Starter Batch ==

=== Introducci√≥n ===
Este documento describe el flujo, configuraci√≥n y componentes involucrados en el proceso de ejecuci√≥n de un //cronjob// utilizando el starter batch.  
Se detallan los requisitos previos, las configuraciones necesarias y los enlaces relevantes a las Implementaciones de Referencia (RI) de cada componente.  
El prop√≥sito del **starter batch** es proporcionar todas las funcionalidades y la autoconfiguraci√≥n necesarias para facilitar la ejecuci√≥n de //cronjobs// definidos en la nube **OpenShift**.

Los //cronjobs// son desplegados en OpenShift <<color:red>> (Enlace chart cronjob) <<color>> con una programaci√≥n deliberadamente inv√°lida, lo que evita su ejecuci√≥n autom√°tica.  
De esta forma, existen en el cl√∫ster pero quedan a la espera de ser disparados por el framework NAUA.  
El encargado de orquestar su activaci√≥n, as√≠ como la gesti√≥n de **jobs**, es el propio framework NAUA, haciendo uso de este starter.

La ejecuci√≥n de cada //job// est√° protegida mediante un mecanismo de seguridad basado en **tokens** y **scopes**, lo que garantiza que solo componentes autorizados puedan iniciar procesos en el entorno de ejecuci√≥n.

=== Requisitos Previos ===
* **üìÑ Cronjob en OpenShift:**  
Es necesario disponer del //cronjob// que se desea ejecutar, desplegado en el entorno de ejecuci√≥n. Este componente debe incorporar el starter batch.

* **üì° Topics Kafka:**  
Es necesario solicitar los topics para comunicaci√≥n entre los componentes. La validaci√≥n y el lanzamiento del cronjob se activan mediante el consumo de eventos.

* **üîê Client ID:**  
Cada batch debe estar asociado a un //client ID// para su trazabilidad y autenticaci√≥n.

=== Funcionalidades del Starter Batch ===

==== Funcionalidades del Starter Batch (Cronjob) ====
El siguiente esquema ilustra la arquitectura funcional relacionada con la ejecucion de Cronjobs del **Starter Batch**.  
En √©l se representan los principales componentes involucrados as√≠ como su interacci√≥n con el sistema de eventos **Kafka**.

{{Diagrama Funcionalidad Cronjob.drawio.png|width=951,height=433}}

===== üõ†Ô∏è JobLaunchHelper: ejecuci√≥n controlada del proceso =====
El componente `JobLaunchHelper` encapsula la l√≥gica necesaria para lanzar un //job// dentro de la arquitectura de referencia.  
Su funci√≥n principal es garantizar que la ejecuci√≥n del proceso batch est√© autorizada y parametrizada de forma segura.

* **Autorizaci√≥n basada en scopes:**  
Cada job define una lista de //scopes// necesarios para su ejecuci√≥n.  
Estos scopes se inyectan mediante un `ConfigMap` por un servicio externo <<color:red>> (ver validador/lanzador gesti√≥n de scopes) <<color>> que valida la petici√≥n.  
Por ejemplo:

{{{
jobLaunchHelper.launchJob(
    userJob,
    List.of("ed-naua-manager"),
    JobScopesOperator.AND
);
}}}

El helper verifica que los scopes requeridos est√°n presentes (seg√∫n `AND` o `OR`). Si no, se rechaza la ejecuci√≥n.

* **Construcci√≥n din√°mica de par√°metros:**  
El helper lee los //JobParameters// definidos <<color:red>> (ver validador/lanzador gesti√≥n de JobParameters) <<color>> y los transforma.  
M√°s info: [[https://docs.spring.io/spring-batch/reference/domain.html#jobParameters]]

* **Ejecuci√≥n controlada:**  
Si la validaci√≥n es exitosa, el job se lanza mediante `JobLauncher`; si no, se env√≠a un evento de rechazo y el contenedor termina con error.

Gracias a este mecanismo, solo los procesos con scopes adecuados pueden activar un job.

===== Notificaciones del resultado de la ejecuci√≥n del job mediante eventos =====
El **starter batch** incluye un sistema de notificaciones v√≠a Kafka sobre la ejecuci√≥n de cada job.

* **‚úÖ Evento OK:** indica ejecuci√≥n correcta  
* **‚ùå Evento KO:** se emite si el job no cumple requisitos, como falta de scopes

Los eventos usan `JobResultEvent` y se publican en:

{{{
tp.<cappCode>.<cronjob>-fin-batch
}}}

* **üì§ Evento OK:** generado por `JobCompletionNotificationService`, incluye `JOB_CORRELATION` si est√° presente  
* **üö´ Evento KO:** emitido por `JobRejectedNotificationService`, con c√≥digo `MISSING_SCOPES`

Esto permite a otros componentes del sistema reaccionar al estado del job.

Para habilitarlo autom√°ticamente, anota la clase principal con `@EnableBatchCronjob`.

Esta anotaci√≥n activa:
* Consumidores de eventos para activar el //cronjob//
* Productores Kafka para eventos de estado
* Listeners y servicios de notificaci√≥n

===== üì£ Job Listener =====
`GissJobCompletionListener` implementa `JobExecutionListener` y recopila informaci√≥n del //job//.

Construye un `JobCompletionDTO` con:
* Identificador y nombre del job
* Par√°metros del proceso
* Estado de salida
* Metadatos: creaci√≥n, inicio, fin, √∫ltima actualizaci√≥n
* Detalle por pasos (steps): nombre, estado, tiempos

Deriva `JobResultCode` del `exitCode`:

{{{
"COMPLETED" ‚Üí SUCCESS  
"FAILED"    ‚Üí FAILED  
"STOPPED"   ‚Üí STOPPED  
"NOOP"      ‚Üí NOOP  
Otro        ‚Üí UNKNOWN
}}}

Se publica a `tp.<cappCode>.<cronjob>-fin-batch` v√≠a `JobCompletionNotificationService`.  
Este listener se registra autom√°ticamente si se usa `@EnableBatchCronjob`.

===== ü™µ Funcionalidades de Logging en Procesos Batch =====
Incluye **listeners de logging** preconfigurados (condicionales seg√∫n config):

* `GissLoggingJobErrorListener`: errores al finalizar un `Job`
* `GissLoggingStepErrorListener`: errores en cada `Step`
* `GissLoggingChunkErrorListener`: errores en chunks
* `GissLoggingWriterListener`: errores al escribir datos

Para desactivarlos:

{{{
giss:
  batch:
    logging-listeners:
      job:
        enabled: false
}}}

El registro autom√°tico se hace v√≠a `LoggingListenersPostProcessor`.

===== üì° Funcionalidades de Tracing en Procesos Batch =====
Incluye `BatchObservabilityBeanPostProcessor` para integrar trazado (//OpenTelemetry// o //Micrometer//).  
M√°s info: [[https://docs.spring.io/spring-batch/reference/tracing.html]]

==== Funcionalidades del Starter Batch (Validador Lanzador) ====
==== Funcionalidades del Starter Batch (Solicitante) ====
==== Funcionalidades del Starter Batch (Comun) ====

---

=== Componentes de la Arquitectura Batch ===

=== 1. Servicio proceso Batch ===
Es el componente principal. Usa el Chart Cronjob para desplegarse en OpenShift.  
Resultado: un recurso Cronjob con programaci√≥n inv√°lida e imagen del servicio con la l√≥gica batch.

==== Configuraci√≥n de dependencias ====
El servicio debe usar:
* starter batch
* starter JPA de NAUA

Spring Batch usa JPA para:
* Persistir estado de ejecuci√≥n
* Reintentar fallos
* Evitar duplicidad

M√°s info: <<color:red>> (Enlace spring batch) <<color>>

{{{
<dependency>
<groupId>es.giss.arch</groupId>
<artifactId>giss-arch-starter-jpa</artifactId>
</dependency>
<dependency>
<groupId>es.giss.arch</groupId>
<artifactId>giss-arch-starter-batch</artifactId>
</dependency>
<dependency>
<groupId>com.oracle.database.jdbc</groupId>
<artifactId>ojdbc8</artifactId>
<scope>runtime</scope>
</dependency>
}}}

==== üîÑ Proceso de ejecuci√≥n del batch ====
Desde la clase principal del servicio (`CommandLineRunner`) se llama a `JobLaunchHelper`:

{{{
@SpringBootApplication
@RequiredArgsConstructor
@EnableScheduling
@EnableBatchCronjob
public class Application implements CommandLineRunner {

    private final Job userJob;
    private final JobLaunchHelper jobLaunchHelper;

    public static void main(final String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(final String... args) {
        jobLaunchHelper.launchJob(
            userJob,
            List.of("ed-naua-manager"),
            JobScopesOperator.AND
        );
    }
}
}}}

El helper valida, construye par√°metros y lanza el job.

==== üß© Integraci√≥n del Listener en los procesos batch ====
El `GissJobCompletionListener` debe registrarse expl√≠citamente en la definici√≥n del //Job//:

{{{
@Configuration
@RequiredArgsConstructor
public class JobConfiguration {

    private final JobRepository jobRepository;
    private final GissJobCompletionListener jobCompletionListener;
    private final GissLoggingJobErrorListener gissLoggingJobErrorListener;
    private final JobLaunchHelper jobLaunchHelper;

    @Qualifier("step1")
    private final Step step1;

    @Qualifier("step2")
    private final Step step2;

    @Bean
    public Job userJob() {
        return new JobBuilder(jobLaunchHelper.getJobNameFromConfigMap(), jobRepository)
                .incrementer(new RunIdIncrementer())
                .listener(jobCompletionListener)
                .listener(gissLoggingJobErrorListener)
                .start(step1)
                .next(step2)
                .build();
    }
}
}}}

Explicaci√≥n:
* `jobCompletionListener`: emite `JobResultEvent`
* `gissLoggingJobErrorListener`: loguea errores
* `RunIdIncrementer`: permite m√∫ltiples ejecuciones

Ambos deben estar como beans Spring. Si usas `@EnableBatchCronjob`, se crean autom√°ticamente.

=== 2. Servicio Validador/Lanzador ===
